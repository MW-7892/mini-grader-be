# ‚öôÔ∏è Mini Grader Backend
This one is for practicing Go. The structure will mainly be golang, GQL, and MySQL

## ‚úÖ Dependencies
* **go** obviously
* **MySQL** or **MariaDB** for the database
* **make** for migration purpose
* [**air**](https://github.com/air-verse/air) for live update on backend. You can use the [shell script installation](https://github.com/air-verse/air?tab=readme-ov-file#via-installsh) to make a binary in this project root (don't forget `air init`).

## üñ•Ô∏è Running the Project
* Migrate the database
```
make migrator
./migrator up
```
* Copy config (also change it to the correct one)
```
cp .env.example .env
```
* Run the server
```
go run .
```

## üìÇ Structure
* `internal`: Main infrastructure of the backend
    * `internal/services`: This part takes data from controllers to process them. Models can only be called from this layer.
    * `internal/models`: The closest part to the database itself, shouldn't be called in the outer layer (we'll see how it goes)
* `graph`: Related to GraphQL, i.e. the API layer.
    * `graph/generated` and `graph/models`: Generated files from the library, no need to worry about it.
    * `graph/schema`: GraphQL schema for the model, you should edit this when you want to modify the model in the API layer
    * `graph/resolvers`: The boilerplates are generated by the command, but you should edit it when a new model in the gql layer is created. Technically this is the controller part to send the data into services
* `database`: Database setup and migrations.
* `utils`: Other utility functions that is common to the entire backend.

## ‚è© Migrations
* When you first use this project, or when you want to migrate after adding a new migration, make sure to run this command first
```
make migrator
```
It will create a binary in `<project_root>/migrator`. Use that to call for database migration

* (Suppose you are in the project root dir) In the topmost level of this repo, you can run the following command to migrate the database.
```
./migrator up
```
* And this is for reroll-ing the migration by one step.
```
./migrator down
```
* To create migration, use this command. Note the the `-dir` should points to the migrations folder (or things can get messy).
```
./migrator create <migration_name>
```

## üìù Generating GQL Types
* Everytime you added or edited new GraphQL model, make sure to run this to generate the new auto-generated files.
```
scripts/genSchema.sh
```
* If you make a new model, make sure to go into `{model_name}.resolvers.go` to connect the resolvers with the database (GORM) part.

## üíª Workflow of Model Creation
* The communication of this backend is (Database ‚Üí Models ‚Üí Services ‚Üí Resolvers ‚Üí GraphQL)
* You first make a model in the models folder with functions to create, updte, or delete, or anything that has to do with the database communication.
* Next, make a new GQL model in the `graph/schema` for the API layer, generate the types using `scripts/genSchema.sh`.
* Make a model service file to connect the GQL layer with the model layer. Note that since the GQL model type and GORM model type is not compatible (somehow, kind of a pain in the neck tbh), you should also define a function to convert these models from or to each other. The service layer shouldn't communicate with the database directly.
* Then, you can call this service function from resolvers. Done!
* For naming convention, try to use the same name for every layer (resolvers, services, models).
